{%- comment -%}Search Page Section{%- endcomment -%}
<section class="tf-page-title" {% if section.settings.background_image != blank %}style="background-image: url('{{ section.settings.background_image | image_url }}');"{% endif %}>
  <div class="container">
    <div class="box-title text-center">
      <h4 class="title">{{ 'general.search.results_with_count' | t: count: search.results_count, terms: search.terms }}</h4>
      <div class="breadcrumb-list">
        <a style="font-size: 14px;" class="breadcrumb-item" href="/">{{ 'general.breadcrumbs.home' | t }}</a>
        <div class="breadcrumb-item dot"><span></span></div>
        <span style="font-size: 14px;" class="breadcrumb-item current">{{ 'templates.search.title' | t }}</span> <br>
      </div>
    </div>
  </div>
</section>

<section class="flat-spacing-24">
  <div class="container">
  {% if search.results_count > 0 %}
    <div class="tf-shop-control">
      <div class="tf-group-filter">
        <div class="tf-dropdown-sort" data-bs-toggle="dropdown">
          <div class="btn-select">
            {%- assign sort_by = search.sort_by | default: 'best-selling' -%}
            <span class="text-sort-value">
              {%- case sort_by -%}
                {%- when 'best-selling' -%}
                  {{ 'collections.sorting.best_selling' | t }}
                {%- when 'title-ascending' -%}
                  {{ 'collections.sorting.az' | t }}
                {%- when 'title-descending' -%}
                  {{ 'collections.sorting.za' | t }}
                {%- when 'price-ascending' -%}
                  {{ 'collections.sorting.price_ascending' | t }}
                {%- when 'price-descending' -%}
                  {{ 'collections.sorting.price_descending' | t }}
                {%- else -%}
                  {{ sort_by | replace: '-', ' ' | capitalize }}
              {%- endcase -%}
            </span>
            <span class="icon icon-arr-down"></span>
          </div>
          <div class="dropdown-menu">
            <div class="select-item{% if search.sort_by == 'best-selling' or search.sort_by == nil %} active{% endif %}" data-sort-value="best-selling">
              <span class="text-value-item">{{ 'collections.sorting.best_selling' | t }}</span>
            </div>
            <div class="select-item{% if search.sort_by == 'title-ascending' %} active{% endif %}" data-sort-value="title-ascending">
              <span class="text-value-item">{{ 'collections.sorting.az' | t }}</span>
            </div>
            <div class="select-item{% if search.sort_by == 'title-descending' %} active{% endif %}" data-sort-value="title-descending">
              <span class="text-value-item">{{ 'collections.sorting.za' | t }}</span>
            </div>
            <div class="select-item{% if search.sort_by == 'price-ascending' %} active{% endif %}" data-sort-value="price-ascending">
              <span class="text-value-item">{{ 'collections.sorting.price_ascending' | t }}</span>
            </div>
            <div class="select-item{% if search.sort_by == 'price-descending' %} active{% endif %}" data-sort-value="price-descending">
              <span class="text-value-item">{{ 'collections.sorting.price_descending' | t }}</span>
            </div>
          </div>
        </div>
      </div>

      <ul class="tf-control-layout">
        <li class="tf-view-layout-switch sw-layout-list list-layout" data-value-layout="list">
          <div class="item icon-list">
            <span></span>
            <span></span>
          </div>
        </li>
        <li class="tf-view-layout-switch sw-layout-2" data-value-layout="tf-col-2">
          <div class="item icon-grid-2">
            <span></span>
            <span></span>
          </div>
        </li>
        <li class="tf-view-layout-switch sw-layout-3" data-value-layout="tf-col-3">
          <div class="item icon-grid-3">
            <span></span>
            <span></span>
            <span></span>
          </div>
        </li>
        <li class="tf-view-layout-switch sw-layout-4 active" data-value-layout="tf-col-4">
          <div class="item icon-grid-4">
            <span></span>
            <span></span>
            <span></span>
            <span></span>
          </div>
        </li>
      </ul>
    </div>

    <!-- Filter Section -->
    <div class="tf-filter-dropdown">
      <span class="title-filter">{{ 'products.facets.filter_button' | t }}:</span>
      <div class="meta-dropdown-filter">
        <div class="dropdown dropdown-filter">
          <div class="dropdown-toggle" id="availability" data-bs-toggle="dropdown" aria-expanded="false" data-bs-auto-close="outside">
            <span class="text-value">{{ 'products.facets.availability' | t }}</span>
            <span class="icon icon-arr-down"></span>
          </div>
          <div class="dropdown-menu" aria-labelledby="availability">
            <ul class="filter-group-check">
              <li class="list-item">
                <input type="radio" name="availability" class="tf-check" id="inStock">
                <label for="inStock" class="label"><span>{{ 'products.facets.in_stock' | t }}</span>&nbsp;<span class="count">({{ search.results | where: "available", true | size }})</span></label>
              </li>
              <li class="list-item">
                <input type="radio" name="availability" class="tf-check" id="outStock">
                <label for="outStock" class="label"><span>{{ 'products.facets.out_of_stock' | t }}</span>&nbsp;<span class="count">({{ search.results | where: "available", false | size }})</span></label>
              </li>
            </ul>
          </div>
        </div>

        <div class="dropdown dropdown-filter">
          <div class="dropdown-toggle" id="price" data-bs-toggle="dropdown" aria-expanded="false" data-bs-auto-close="outside">
            <span class="text-value">{{ 'products.facets.price_label' | t }}</span>
            <span class="icon icon-arr-down"></span>
          </div>
          <div class="dropdown-menu" aria-labelledby="price">
            <div class="widget-price filter-price">
              <div class="price-val-range" id="price-value-range" data-min="0" data-max="500"></div>
              <div class="box-value-price">
                <span class="text-sm">{{ 'sections.main-collection-product-grid.price_range_label' | t }}:</span>
                <div class="price-box">
                  <div class="price-val" id="price-min-value" data-currency="$"></div>
                  <span>-</span>
                  <div class="price-val" id="price-max-value" data-currency="$"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        {% assign vendors = search.results | map: 'vendor' | uniq %}
        {% assign has_vendors = false %}
        {% for vendor in vendors %}
          {% if vendor != blank %}
            {% assign has_vendors = true %}
            {% break %}
          {% endif %}
        {% endfor %}
        
        {% if has_vendors %}
          <div class="dropdown dropdown-filter">
            <div class="dropdown-toggle" id="brand" data-bs-toggle="dropdown" aria-expanded="false" data-bs-auto-close="outside">
              <span class="text-value">{{ 'products.facets.brand_label' | t }}</span>
              <span class="icon icon-arr-down"></span>
            </div>
            <div class="dropdown-menu" aria-labelledby="brand">
              <ul class="filter-group-check">
                {% for vendor in vendors %}
                  {% if vendor != blank %}
                    <li class="list-item">
                      <input type="radio" name="brand" class="tf-check" id="{{ vendor | handle }}">
                      <label for="{{ vendor | handle }}" class="label">
                        <span>{{ vendor }}</span>&nbsp;
                        <span class="count">({{ search.results | where: "vendor", vendor | size }})</span>
                      </label>
                    </li>
                  {% endif %}
                {% endfor %}
              </ul>
            </div>
          </div>
        {% endif %}
      </div>
    </div>

    {% paginate search.results by section.settings.products_per_page %}
      <div class="wrapper-control-shop">
        <div class="meta-filter-shop" style="display: {% if current_tags.size > 0 or request.search != blank %}flex{% else %}none{% endif %};">
          <div id="product-count-grid" class="count-text"><span class="count">{{ search.results_count }}</span> Products found</div>
          <div id="product-count-list" class="count-text"><span class="count">{{ search.results_count }}</span> Products found</div>
          <div id="applied-filters">
            {% if current_tags.size > 0 %}
              {% for tag in current_tags %}
                <span class="filter-tag">{{ tag }} <i class="icon icon-close"></i></span>
              {% endfor %}
            {% endif %}
          </div>
          {% if current_tags.size > 0 %}
            <button id="remove-all" class="remove-all-filters"><i class="icon icon-close"></i> {{ 'products.facets.clear_all' | t }}</button>
          {% endif %}
        </div>

        <!-- List View Layout -->
        <div class="tf-list-layout wrapper-shop" id="listLayout" style="display: none;">
          {% for item in search.results %}
            {% if item.object_type == 'product' %}
              <div class="loadItem card-product style-list" data-availability="{{ item.available | default: 'In stock' }}" data-brand="{{ item.vendor }}">
                {% render 'card-product', product: item, show_color_swatches: true, show_size_swatches: true, show_case_type: true, size_swatches: true %}
              </div>
            {% endif %}
          {% endfor %}

          <!-- Pagination for List View -->
          {% if paginate.pages > 1 %}
            <div class="pagination-wrapper text-center mt-5">
              <ul class="wg-pagination">
                {% if paginate.previous %}
                  <li>
                    <a href="{{ paginate.previous.url }}{% if request.query_string != blank %}&{{ request.query_string | replace: 'page=', '' | replace: '&page=', '' }}{% endif %}" class="pagination-item">
                      <i class="icon-arr-left"></i>
                    </a>
                  </li>
                {% endif %}
                
                {% for part in paginate.parts %}
                  {% if part.is_link %}
                    <li>
                      <a href="{{ part.url }}{% if request.query_string != blank %}&{{ request.query_string | replace: 'page=', '' | replace: '&page=', '' }}{% endif %}" class="pagination-item">{{ part.title }}</a>
                    </li>
                  {% else %}
                    <li class="{% if part.title == paginate.current_page %}active{% endif %}">
                      <div class="pagination-item">{{ part.title }}</div>
                    </li>
                  {% endif %}
                {% endfor %}

                {% if paginate.next %}
                  <li>
                    <a href="{{ paginate.next.url }}{% if request.query_string != blank %}&{{ request.query_string | replace: 'page=', '' | replace: '&page=', '' }}{% endif %}" class="pagination-item">
                      <i class="icon-arr-right2"></i>
                    </a>
                  </li>
                {% endif %}
              </ul>
            </div>
          {% endif %}
        </div>

        <!-- Grid View Layout -->
        <div class="wrapper-shop tf-grid-layout tf-col-4" id="gridLayout">
          {% for item in search.results %}
            {% if item.object_type == 'product' %}
              <div class="loadItem card-product grid style-1{% if item.options contains 'Size' %} card-product-size{% endif %}" 
                   data-availability="{{ item.available | default: 'In stock' }}" 
                   data-brand="{{ item.vendor }}">
                {% render 'card-product', product: item %}
              </div>
            {% endif %}
          {% endfor %}

          <!-- Pagination for Grid View -->
          {% if paginate.pages > 1 %}
            <div class="pagination-wrapper text-center mt-5">
              <ul class="wg-pagination">
                {% if paginate.previous %}
                  <li>
                    <a href="{{ paginate.previous.url }}{% if request.query_string != blank %}&{{ request.query_string | replace: 'page=', '' | replace: '&page=', '' }}{% endif %}" class="pagination-item">
                      <i class="icon-arr-left"></i>
                    </a>
                  </li>
                {% endif %}
                
                {% for part in paginate.parts %}
                  {% if part.is_link %}
                    <li>
                      <a href="{{ part.url }}{% if request.query_string != blank %}&{{ request.query_string | replace: 'page=', '' | replace: '&page=', '' }}{% endif %}" class="pagination-item">{{ part.title }}</a>
                    </li>
                  {% else %}
                    <li class="{% if part.title == paginate.current_page %}active{% endif %}">
                      <div class="pagination-item">{{ part.title }}</div>
                    </li>
                  {% endif %}
                {% endfor %}

                {% if paginate.next %}
                  <li>
                    <a href="{{ paginate.next.url }}{% if request.query_string != blank %}&{{ request.query_string | replace: 'page=', '' | replace: '&page=', '' }}{% endif %}" class="pagination-item">
                      <i class="icon-arr-right2"></i>
                    </a>
                  </li>
                {% endif %}
              </ul>
            </div>
          {% endif %}
        </div>
      </div>
    {% endpaginate %}
  {% else %}
    <p>{{ 'general.search.no_results_html' | t: terms: search.terms }}</p>
  {% endif %}
</div>
</section>

{%- comment -%}Recently Viewed Section for Search Page{%- endcomment -%}
{%- comment -%}Include the recently viewed tracking script{%- endcomment -%}
{% render 'recently-viewed-tracking' %}

<section class="flat-spacing" id="search-recently-viewed-section" style="display: none;">
  <div class="container">
    <div class="flat-title wow fadeInUp">
      <h4 class="title">Recently Viewed Products</h4>
    </div>
    <div class="hover-sw-nav hover-sw-2 wow wrap-pos-nav sw-over-product fadeInUp">
      <div dir="ltr" class="swiper tf-swiper wrap-sw-over" data-swiper='{
        "slidesPerView": 2,
        "spaceBetween": 12,
        "speed": 800,
        "observer": true,
        "observeParents": true,
        "slidesPerGroup": 2,
        "navigation": {
          "clickable": true,
          "nextEl": ".nav-next-search-viewed",
          "prevEl": ".nav-prev-search-viewed"
        },
        "pagination": { "el": ".sw-pagination-search-viewed", "clickable": true },
        "breakpoints": {
          "768": { 
            "slidesPerView": 3, 
            "spaceBetween": 12, 
            "slidesPerGroup": 3
          },
          "1200": { 
            "slidesPerView": 4, 
            "spaceBetween": 12, 
            "slidesPerGroup": 4
          }
        }
      }'>
        <div class="swiper-wrapper" id="search-recently-viewed-products">
          <!-- Products will be populated by JavaScript -->
        </div>
        <div class="d-flex d-xl-none sw-dot-default sw-pagination-search-viewed justify-content-center"></div>
      </div>
      <div class="d-none d-xl-flex swiper-button-next nav-swiper nav-next-search-viewed"></div>
      <div class="d-none d-xl-flex swiper-button-prev nav-swiper nav-prev-search-viewed"></div>
    </div>
  </div>
</section>

<script>
  
  // Inject styles into head
  document.addEventListener('DOMContentLoaded', function() {
    // Set default sort if none is specified
    const url = new URL(window.location.href);
    if (!url.searchParams.has('sort_by')) {
      url.searchParams.set('sort_by', 'best-selling');
      window.history.replaceState({}, '', url.toString());
      updateProductsWithSort('best-selling');
    }

    // Handle sort selection
    const sortItems = document.querySelectorAll('.select-item');
    const sortDropdown = document.querySelector('.tf-dropdown-sort');
    const sortValueDisplay = document.querySelector('.text-sort-value');
    const productGrid = document.querySelector('.tf-grid-layout');
    const productList = document.querySelector('.tf-list-layout');
    const productCountGrid = document.getElementById('product-count-grid');
    const productCountList = document.getElementById('product-count-list');

    // Function to update products with new sort
    async function updateProductsWithSort(sortValue) {
      const url = new URL(window.location.href);
      const existingParams = new URLSearchParams(url.search);
      
      // Reset to page 1 when applying filters or changing sort
      existingParams.delete('page');
      
      // Handle alphabetical sorting on client side
      if (sortValue === 'title-ascending' || sortValue === 'title-descending') {
        console.log('Triggering alphabetical sorting:', sortValue);
        // Remove sort_by parameter for alphabetical sorting to get unsorted results
        existingParams.delete('sort_by');
        
        try {
          const response = await fetch(url.pathname + '?' + existingParams.toString());
          const html = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');

          // Update product grid
          const newGrid = doc.querySelector('.tf-grid-layout');
          const newList = doc.querySelector('.tf-list-layout');
          
          if (newGrid && productGrid) {
            const currentLayoutClass = productGrid.className;
            
            // Get all child nodes from the fetched grid, including text nodes (whitespace)
            const allNodes = Array.from(newGrid.childNodes);
            
            // Separate product elements from other nodes (like whitespace)
            const products = allNodes.filter(node => node.nodeType === 1 && node.classList.contains('card-product'));
            
            products.sort((a, b) => {
              const titleA = a.querySelector('.name-product')?.textContent?.trim() || '';
              const titleB = b.querySelector('.name-product')?.textContent?.trim() || '';
              
              if (sortValue === 'title-ascending') {
                return titleA.localeCompare(titleB);
              } else {
                return titleB.localeCompare(titleA);
              }
            });
            
            // Re-render the live grid once with the sorted products
            productGrid.innerHTML = products.map(p => p.outerHTML).join('\n');
            productGrid.className = currentLayoutClass;
          }

          // Update product list
          if (newList && productList) {
            const allNodes = Array.from(newList.childNodes);
            const products = allNodes.filter(node => node.nodeType === 1 && node.classList.contains('card-product'));
            
            products.sort((a, b) => {
              const titleA = a.querySelector('.name-product')?.textContent?.trim() || '';
              const titleB = b.querySelector('.name-product')?.textContent?.trim() || '';
              
              if (sortValue === 'title-ascending') {
                return titleA.localeCompare(titleB);
              } else {
                return titleB.localeCompare(titleA);
              }
            });
            
            productList.innerHTML = products.map(p => p.outerHTML).join('\n');
          }

          // Update sort value display
          if (sortValueDisplay) {
            const sortItem = document.querySelector(`.select-item[data-sort-value="${sortValue}"]`);
            if (sortItem) {
                sortValueDisplay.textContent = sortItem.querySelector('.text-value-item').textContent.trim();
            } else {
                // Fallback
                sortValueDisplay.textContent = sortValue.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
          }

          // Update active state
          sortItems.forEach(item => {
            item.classList.toggle('active', item.dataset.sortValue === sortValue);
          });

          // Update URL without reload, preserving all filter parameters
          existingParams.set('sort_by', sortValue);
          window.history.pushState({}, '', url.pathname + '?' + existingParams.toString());

          // Reinitialize any necessary event listeners
          initializeProductEvents();
        } catch (error) {
          console.error('Error updating products:', error);
        }
      } else {
        // Handle server-side sorting for other options
        existingParams.set('sort_by', sortValue);
        
        try {
          const response = await fetch(url.pathname + '?' + existingParams.toString());
          const html = await response.text();
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');

          // Update product grid
          const newGrid = doc.querySelector('.tf-grid-layout');
          const newList = doc.querySelector('.tf-list-layout');
          
          if (newGrid && productGrid) {
            const currentLayoutClass = productGrid.className;
            productGrid.innerHTML = newGrid.innerHTML;
            productGrid.className = currentLayoutClass;
          }
          
          if (newList && productList) {
            productList.innerHTML = newList.innerHTML;
          }

          // Update sort value display
          if (sortValueDisplay) {
            const sortItem = document.querySelector(`.select-item[data-sort-value="${sortValue}"]`);
            if (sortItem) {
                sortValueDisplay.textContent = sortItem.querySelector('.text-value-item').textContent.trim();
            } else {
                // Fallback
                sortValueDisplay.textContent = sortValue.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
          }

          // Update active state
          sortItems.forEach(item => {
            item.classList.toggle('active', item.dataset.sortValue === sortValue);
          });

          // Update URL without reload
          window.history.pushState({}, '', url.pathname + '?' + existingParams.toString());

          // Reinitialize any necessary event listeners
          initializeProductEvents();
        } catch (error) {
          console.error('Error updating products:', error);
        }
      }
    }

    // Handle sort selection
    sortItems.forEach(item => {
      item.addEventListener('click', function() {
        const sortValue = this.dataset.sortValue;
        updateProductsWithSort(sortValue);
        
        // Close dropdown after selection
        if (sortDropdown) {
          const dropdown = bootstrap.Dropdown.getInstance(sortDropdown);
          if (dropdown) {
            dropdown.hide();
          }
        }
      });
    });

    // Handle layout switching
    const layoutSwitches = document.querySelectorAll('.tf-view-layout-switch');
    const listLayout = document.getElementById('listLayout');
    const gridLayout = document.getElementById('gridLayout');

    layoutSwitches.forEach(switchEl => {
      switchEl.addEventListener('click', function() {
        const layout = this.dataset.valueLayout;
        
        // Update active state
        layoutSwitches.forEach(s => s.classList.remove('active'));
        this.classList.add('active');

        // Show/hide layouts
        if (listLayout && gridLayout) {
          const hasProducts = gridLayout.querySelector('.card-product');

          listLayout.style.display = layout === 'list' ? 'block' : 'none';
          gridLayout.style.display = layout === 'list' ? 'none' : '';
          
          if (layout !== 'list' && hasProducts) {
            gridLayout.classList.remove('tf-col-2', 'tf-col-3', 'tf-col-4');
            if (!gridLayout.classList.contains('tf-grid-layout')) {
              gridLayout.classList.add('tf-grid-layout');
            }
            gridLayout.classList.add(layout);
          }
          
          // Update product count visibility based on layout
          if (productCountGrid) {
            productCountGrid.style.display = layout === 'list' ? 'none' : 'block';
          }
          if (productCountList) {
            productCountList.style.display = layout === 'list' ? 'block' : 'none';
          }
        }
      });
    });

    // Handle filter tag removal
    const filterTags = document.querySelectorAll('.filter-tag');
    filterTags.forEach(tag => {
      tag.addEventListener('click', function() {
        const tagText = this.textContent.trim();
        const url = new URL(window.location.href);
        const tags = url.searchParams.get('filter.v.tag')?.split(',') || [];
        const newTags = tags.filter(t => t !== tagText);
        
        if (newTags.length > 0) {
          url.searchParams.set('filter.v.tag', newTags.join(','));
        } else {
          url.searchParams.delete('filter.v.tag');
        }
        
        // Reset to page 1 when applying filters
        url.searchParams.delete('page');
        
        updateProductsWithSort(url.searchParams.get('sort_by') || 'best-selling');
      });
    });

    // Handle clear all filters
    const clearAllBtn = document.getElementById('remove-all');
    if (clearAllBtn) {
      clearAllBtn.addEventListener('click', function() {
        const url = new URL(window.location.href);
        // Remove all filter parameters
        for (const param of url.searchParams.keys()) {
          if (param.startsWith('filter.v.')) {
            url.searchParams.delete(param);
          }
        }
        
        // Reset to page 1 when applying filters
        url.searchParams.delete('page');
        
        updateProductsWithSort(url.searchParams.get('sort_by') || 'best-selling');
      });
    }

    // Handle availability filter
    const availabilityInputs = document.querySelectorAll('input[name="availability"]');
    availabilityInputs.forEach(input => {
      input.addEventListener('change', async function() {
        const url = new URL(window.location.href);
        if (this.checked) {
          const value = this.id === 'inStock' ? '1' : '0';
          url.searchParams.set('filter.v.availability', value);
        } else {
          url.searchParams.delete('filter.v.availability');
        }

        // Reset to page 1 when applying filters
        url.searchParams.delete('page');

        // Update URL first
        window.history.pushState({}, '', url.toString());
        
        // Use updateProductsWithSort to maintain current sort order
        const currentSort = url.searchParams.get('sort_by') || 'best-selling';
        updateProductsWithSort(currentSort);
      });
    });

    // Handle brand filter
    const brandInputs = document.querySelectorAll('input[name="brand"]');
    brandInputs.forEach(input => {
      input.addEventListener('change', async function() {
        const url = new URL(window.location.href);
        if (this.checked) {
          url.searchParams.set('filter.v.option.brand', this.id);
        } else {
          url.searchParams.delete('filter.v.option.brand');
        }

        // Reset to page 1 when applying filters
        url.searchParams.delete('page');

        // Update URL first
        window.history.pushState({}, '', url.toString());
        
        // Use updateProductsWithSort to maintain current sort order
        const currentSort = url.searchParams.get('sort_by') || 'best-selling';
        updateProductsWithSort(currentSort);
      });
    });

    // Initialize price range slider
    const priceRange = document.getElementById('price-value-range');
    if (priceRange) {
      const minPrice = parseInt(priceRange.dataset.min);
      const maxPrice = parseInt(priceRange.dataset.max);
      
      noUiSlider.create(priceRange, {
        start: [minPrice, maxPrice],
        connect: true,
        range: {
          'min': 0,
          'max': 500
        }
      });

      const minValue = document.getElementById('price-min-value');
      const maxValue = document.getElementById('price-max-value');
      const currency = minValue.dataset.currency;

      priceRange.noUiSlider.on('update', function(values) {
        minValue.textContent = currency + Math.round(values[0]);
        maxValue.textContent = currency + Math.round(values[1]);
      });

      // Handle price range changes
      priceRange.noUiSlider.on('change', function(values) {
        const url = new URL(window.location.href);
        url.searchParams.set('filter.v.price.gte', Math.round(values[0]));
        url.searchParams.set('filter.v.price.lte', Math.round(values[1]));
        
        // Reset to page 1 when applying filters
        url.searchParams.delete('page');
        
        updateProductsWithSort(url.searchParams.get('sort_by') || 'best-selling');
      });
    }

    // Function to initialize product-specific event listeners
    function initializeProductEvents() {
      // Add any product-specific event listeners here
      // For example, quick view, add to cart, etc.
    }

    // Initialize product events
    initializeProductEvents();

    // Initialize layout state
    function initializeLayoutState() {
      // Set default layout to grid view
      const defaultLayout = 'tf-col-4';
      const listLayout = document.getElementById('listLayout');
      const gridLayout = document.getElementById('gridLayout');
      
      if (listLayout && gridLayout) {
        // Show grid layout by default, hide list layout
        listLayout.style.display = 'none';
        gridLayout.style.display = '';
        
        // Ensure grid layout has proper classes
        if (!gridLayout.classList.contains('tf-grid-layout')) {
          gridLayout.classList.add('tf-grid-layout');
        }
        gridLayout.classList.remove('tf-col-2', 'tf-col-3', 'tf-col-4');
        gridLayout.classList.add(defaultLayout);
        
        // Set active state for layout switches
        const layoutSwitches = document.querySelectorAll('.tf-view-layout-switch');
        layoutSwitches.forEach(switchEl => {
          switchEl.classList.remove('active');
          if (switchEl.dataset.valueLayout === defaultLayout) {
            switchEl.classList.add('active');
          }
        });
        
        // Show/hide product counts based on default layout
        if (productCountGrid) {
          productCountGrid.style.display = 'block';
        }
        if (productCountList) {
          productCountList.style.display = 'none';
        }
      }
    }

    // Initialize layout state
    initializeLayoutState();

    const searchSection = document.getElementById('search-recently-viewed-section');
    const searchProductsContainer = document.getElementById('search-recently-viewed-products');
    
    if (!searchSection || !searchProductsContainer) return;
    
    // Function to render recently viewed products for search page
    async function renderSearchRecentlyViewedProducts() {
      if (typeof window.RecentlyViewedManager === 'undefined') {
        console.warn('RecentlyViewedManager not available');
        return;
      }
      
      // Get recently viewed products (no current product to exclude on search page)
      const recentlyViewed = window.RecentlyViewedManager.getProducts().slice(0, 8);
      
      if (recentlyViewed.length === 0) {
        searchSection.style.display = 'none';
        return;
      }
      
      // Show the section
      searchSection.style.display = 'block';
      
      // Clear existing products
      searchProductsContainer.innerHTML = '';
      
      // Fetch full product data for each recently viewed product
      const productPromises = recentlyViewed.map(async (product) => {
        try {
          const response = await fetch(`/products/${product.handle}.js`);
          if (!response.ok) throw new Error('Failed to fetch product data');
          return await response.json();
        } catch (error) {
          console.error('Error fetching product data for', product.handle, error);
          // Return the basic product data if fetch fails
          return product;
        }
      });
      
      const fullProductData = await Promise.all(productPromises);
      
      // Render each product using the card-product snippet structure
      fullProductData.forEach(function(product) {
        const slide = document.createElement('div');
        slide.className = 'swiper-slide';
        
        // Create product card HTML that matches the card-product snippet structure
        slide.innerHTML = `
          <div class="card-product style-1" data-availability="${product.available ? 'In stock' : 'Out of stock'}" data-brand="${product.vendor || ''}">
            <div class="card-product-wrapper asp-ratio-1">
              <a href="${product.url}" class="product-img">
                ${product.featured_image ? 
                  `<img class="img-product lazyloaded" src="${product.featured_image}" alt="${product.title}" loading="lazy">` :
                  `<div class="placeholder-svg">${product.title}</div>`
                }
                ${product.images && product.images[1] ? 
                  `<img class="img-hover lazyloaded" src="${product.images[1]}" alt="${product.title}" loading="lazy">` : ''
                }
              </a>
              
              ${product.compare_at_price && product.compare_at_price > product.price ? 
                `<div class="on-sale-wrap">
                  <span class="on-sale-item">${Math.round((product.compare_at_price - product.price) / product.compare_at_price * 100)}% Off</span>
                </div>` : ''
              }
              
              ${product.available ? `
              <ul class="list-product-btn">
                <li>
                  <a href="javascript:void(0);" 
                     class="box-icon hover-tooltip tooltip-left add-to-cart" 
                     data-variant-id="${product.variants ? product.variants[0].id : product.id}"
                     data-quantity="1"
                     aria-label="Add to cart">
                    <i class="icon icon-cart"></i>
                    <span class="tooltip">Add to cart</span>
                  </a>
                </li>
                <li class="wishlist">
                  <a href="javascript:void(0);" 
                     class="box-icon hover-tooltip tooltip-left" 
                     data-wishlist 
                     data-id="${product.id}" 
                     data-action="add"
                     aria-label="Add to wishlist">
                    <span class="icon icon-heart2"></span>
                    <span class="tooltip">Add to wishlist</span>
                  </a>
                </li>
                <li>
                  <a href="javascript:void(0);" 
                     class="box-icon hover-tooltip tooltip-left quickview" 
                     data-product-handle="${product.handle}"
                     data-product-id="${product.id}"
                     data-bs-toggle="modal" 
                     data-bs-target="#quickView">
                    <span class="icon icon-view"></span>
                    <span class="tooltip">Quick view</span>
                  </a>
                </li>
                <li class="compare">
                  <a href="javascript:void(0);" 
                     class="box-icon hover-tooltip tooltip-left" 
                     data-compare 
                     data-id="${product.id}" 
                     data-action="add"
                     aria-label="Add to compare">
                    <span class="icon icon-compare"></span>
                    <span class="tooltip">Add to compare</span>
                  </a>
                </li>
              </ul>
              ` : ''}
            </div>
            
            <div class="card-product-info">
              <a href="${product.url}" class="name-product link fw-medium text-md">${product.title}</a>
              <p class="price-wrap fw-medium">
                ${product.compare_at_price && product.compare_at_price > product.price ? 
                  `<span class="price-new text-primary">${formatMoney(product.price)}</span>
                   <span class="price-old">${formatMoney(product.compare_at_price)}</span>` :
                  `<span class="price-new">${formatMoney(product.price)}</span>`
                }
              </p>
            </div>
          </div>
        `;
        
        searchProductsContainer.appendChild(slide);
      });
      
      // Initialize product card functionality for the newly added products
      if (typeof ProductCard !== 'undefined') {
        try {
          ProductCard.initializeForDynamicProducts(searchProductsContainer);
        } catch (error) {
          console.warn('Error initializing product card functionality for search recently viewed products:', error);
        }
      } else {
        console.warn('ProductCard module not available for search recently viewed products');
      }
    }
    
    // Helper function to format money (basic implementation)
    function formatMoney(cents) {
      if (typeof cents !== 'number') return '';
      
      // Try to use Shopify's money format if available
      if (typeof window.Shopify !== 'undefined' && window.Shopify.formatMoney) {
        return window.Shopify.formatMoney(cents);
      }
      
      // Fallback to basic formatting
      const dollars = cents / 100;
      return '$' + dollars.toFixed(2);
    }
    
    // Initial render
    renderSearchRecentlyViewedProducts();
    
    // Listen for updates to recently viewed products
    window.addEventListener('recentlyViewedUpdated', function() {
      renderSearchRecentlyViewedProducts();
    });
    
    // Re-render when section becomes visible (for lazy loading)
    const observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          renderSearchRecentlyViewedProducts();
        }
      });
    });
    
    observer.observe(searchSection);
  });
</script>

{% schema %}
{
  "name": "Search Page",
  "settings": [
    {
      "type": "image_picker",
      "id": "background_image",
      "label": "Background Image",
      "info": "Background image for the search page banner"
    },
    {
      "type": "range",
      "id": "products_per_page",
      "label": "Products per page",
      "min": 1,
      "max": 24,
      "default": 12
    }
  ]
}
{% endschema %} 